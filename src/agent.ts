import dotenv from "dotenv";
import { ChatOpenAI } from "@langchain/openai";
import { tool } from "@langchain/core/tools";
import { z } from "zod";
import fs from "node:fs/promises";
import path from "node:path";
import { StateGraph, START, MessagesAnnotation } from "@langchain/langgraph";
import { ToolNode, toolsCondition } from "@langchain/langgraph/prebuilt";

const cfg = dotenv.config({ path: ".env" });

const GENERATED_DIR = path.resolve(process.cwd(), "generated");

export const ensureGeneratedDir = async () => {
  try {
    await fs.mkdir(GENERATED_DIR, { recursive: true });
  } catch {}
};

const resolveGeneratedPath = (name: string) => {
  if (!name || typeof name !== "string") throw new Error("Invalid filename");
  if (path.isAbsolute(name)) throw new Error("Absolute paths are not allowed");
  const normalized = path.normalize(name);
  const resolved = path.resolve(GENERATED_DIR, normalized);
  if (
    !resolved.startsWith(GENERATED_DIR + path.sep) &&
    resolved !== GENERATED_DIR
  ) {
    throw new Error("Path traversal is not allowed");
  }
  return resolved;
};

const listFilesRecursive = async (
  dir: string,
  base: string,
): Promise<string[]> => {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files: string[] = [];
  for (const entry of entries) {
    const full = path.join(dir, entry.name);
    const relative = path.relative(base, full);
    if (entry.isDirectory()) {
      const nested = await listFilesRecursive(full, base);
      files.push(...nested);
      continue;
    }
    files.push(relative);
  }
  return files;
};

const fileModificationTool = tool(
  async ({
    operation,
    filename,
    content,
  }: {
    operation: "create" | "update";
    filename: string;
    content: string;
  }) => {
    await ensureGeneratedDir();
    const target = resolveGeneratedPath(filename);
    if (operation === "create") {
      await fs.writeFile(target, content ?? "", "utf8");
      return JSON.stringify({
        status: "created",
        path: path.relative(process.cwd(), target),
      });
    }
    await fs.writeFile(target, content ?? "", "utf8");
    return JSON.stringify({
      status: "updated",
      path: path.relative(process.cwd(), target),
    });
  },
  {
    name: "file_modification_tool",
    description:
      "Create or update a file inside the ./generated directory. Provide operation ('create' or 'update'), filename (relative path), and content.",
    schema: z.object({
      operation: z.enum(["create", "update"]),
      filename: z.string().min(1),
      content: z.string().default(""),
    }),
  },
);

const listAvailableFilesTool = tool(
  async () => {
    await ensureGeneratedDir();
    const files = await listFilesRecursive(GENERATED_DIR, GENERATED_DIR);
    return JSON.stringify({ directory: "generated", files });
  },
  {
    name: "list_available_files_tool",
    description:
      "List files currently available to the agent inside ./generated.",
    schema: z.object({}),
  },
);

const readFilesTool = tool(
  async ({ filenames }: { filenames: string[] }) => {
    await ensureGeneratedDir();
    const result: Record<string, string> = {};
    for (const name of filenames) {
      const fp = resolveGeneratedPath(name);
      try {
        const data = await fs.readFile(fp, "utf8");
        result[name] = data;
      } catch (e: unknown) {
        const msg = e instanceof Error ? e.message : String(e);
        result[name] = `ERROR: ${msg}`;
      }
    }
    return JSON.stringify(result);
  },
  {
    name: "read_files_tool",
    description:
      "Read the contents of one or more files inside ./generated by providing their relative paths.",
    schema: z.object({ filenames: z.array(z.string().min(1)).min(1) }),
  },
);

const tools = [fileModificationTool, listAvailableFilesTool, readFilesTool];

const model = new ChatOpenAI({
  apiKey: cfg.parsed?.OPENAI_API_KEY,
  model: "o4-mini",
  streaming: true,
  useResponsesApi: true,
  reasoning: {
    effort: "low",
    summary: "auto",
  },
});
const modelWithTools = model.bindTools(tools);

export const extractReasoningText = (msg: any): string | null => {
  const reasoning = msg?.additional_kwargs?.reasoning;
  if (!reasoning) return null;
  const summary = Array.isArray(reasoning.summary) ? reasoning.summary : [];
  const text = summary
    .map((p: any) => (typeof p?.text === "string" ? p.text : ""))
    .filter(Boolean)
    .join("");
  if (text) return text;
  if (typeof reasoning.text === "string") return reasoning.text;
  try {
    const str = JSON.stringify(reasoning);
    return str.length > 2 ? str : null;
  } catch {
    return null;
  }
};

const callModel = async (state: typeof MessagesAnnotation.State) => {
  const response = await modelWithTools.invoke(state.messages);
  return { messages: [response] };
};

const toolNode = new ToolNode(tools);

export const graph = new StateGraph(MessagesAnnotation)
  .addNode("assistant", callModel)
  .addNode("tools", toolNode)
  .addEdge(START, "assistant")
  .addConditionalEdges("assistant", toolsCondition)
  .addEdge("tools", "assistant")
  .compile();
